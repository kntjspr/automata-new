/**
 * CFG to PDA Conversion Algorithm - Graphviz DOT Representation
 * 
 * This file contains the Graphviz DOT code that visualizes the actual
 * algorithm used in the C++ implementation (pda.cpp) to convert a 
 * Context-Free Grammar to a Pushdown Automaton.
 * 
 * To render: Save as .dot file and run: dot -Tpng cfg_to_pda_algorithm.dot -o algorithm.png
 * Or paste into https://viz-js.com/
 */

// ============================================================
// ALGORITHM FLOWCHART (CFG::toPDA in pda.cpp, lines 342-370)
// ============================================================

/*
digraph CFG_to_PDA_Algorithm {
    // Graph settings
    rankdir=TB;
    bgcolor="#1a1a2e";
    fontcolor="white";
    node [fontname="Consolas", fontsize=11, color="white", fontcolor="white"];
    edge [fontname="Consolas", fontsize=10, color="#ccff00", fontcolor="#00ffff"];
    
    // Title
    labelloc="t";
    label="CFG → PDA Conversion Algorithm\n(Standard Construction)";
    fontsize=16;
    fontcolor="#ccff00";
    
    // Start
    start [shape=ellipse, label="START\nInput: CFG G = (V, Σ, R, S)", style=filled, fillcolor="#00ffff", fontcolor="black"];
    
    // Step 1: Create PDA states
    step1 [shape=box, label="Step 1: Create 3 PDA states\n\nq0 = addState(\"start\", false)\nq1 = addState(\"loop\", false)\nq2 = addState(\"accept\", true)", style="rounded,filled", fillcolor="#2a2a4e"];
    
    // Step 2: Set start state and initial stack
    step2 [shape=box, label="Step 2: Initialize\n\nsetStartState(q0)\nsetInitialStackSymbol('Z')", style="rounded,filled", fillcolor="#2a2a4e"];
    
    // Step 3: Add initial transition (push start symbol)
    step3 [shape=box, label="Step 3: Push start symbol\n\naddTransition(q0, q1, ε, Z, SZ)\n\n// Read nothing, pop Z, push S then Z", style="rounded,filled", fillcolor="#3a3a5e"];
    
    // Step 4: Loop through productions
    step4_init [shape=diamond, label="For each\nproduction\nA → w in R", style=filled, fillcolor="#ff0099", fontcolor="white"];
    
    step4_body [shape=box, label="Step 4: Add production transition\n\nreversed = reverse(w)\naddTransition(q1, q1, ε, A, reversed)\n\n// Pop A, push w in reverse order\n// (so first symbol of w is on top)", style="rounded,filled", fillcolor="#3a3a5e"];
    
    step4_done [shape=point, width=0.1];
    
    // Step 5: Loop through terminals
    step5_init [shape=diamond, label="For each\nterminal\na in Σ", style=filled, fillcolor="#ff0099", fontcolor="white"];
    
    step5_body [shape=box, label="Step 5: Add terminal match transition\n\naddTransition(q1, q1, a, a, ε)\n\n// Read 'a', pop 'a', push nothing\n// (matches input with stack top)", style="rounded,filled", fillcolor="#3a3a5e"];
    
    step5_done [shape=point, width=0.1];
    
    // Step 6: Add accept transition
    step6 [shape=box, label="Step 6: Add accept transition\n\naddTransition(q1, q2, ε, Z, ε)\n\n// Accept when stack has only Z\n// (all symbols processed)", style="rounded,filled", fillcolor="#3a3a5e"];
    
    // End
    end [shape=ellipse, label="RETURN PDA\n\nM = ({q0,q1,q2}, Σ, Γ, δ, q0, Z, {q2})", style=filled, fillcolor="#ccff00", fontcolor="black"];
    
    // Flow edges
    start -> step1;
    step1 -> step2;
    step2 -> step3;
    step3 -> step4_init;
    
    step4_init -> step4_body [label="more"];
    step4_body -> step4_init [label="next"];
    step4_init -> step4_done [label="done"];
    
    step4_done -> step5_init;
    
    step5_init -> step5_body [label="more"];
    step5_body -> step5_init [label="next"];
    step5_init -> step5_done [label="done"];
    
    step5_done -> step6;
    step6 -> end;
    
    // Annotations
    subgraph cluster_legend {
        label="C++ Code Reference: pda.cpp lines 342-370";
        style=dashed;
        color="#666666";
        fontcolor="#888888";
        
        legend1 [shape=none, label="ε = EPSILON (empty string)", fontcolor="#888888"];
        legend2 [shape=none, label="δ = transition function", fontcolor="#888888"];
        legend1 -> legend2 [style=invis];
    }
}
*/

// ============================================================
// RESULTING PDA STRUCTURE (output of the algorithm)
// ============================================================

/*
digraph RNA_PDA {
    rankdir=LR;
    bgcolor="#1a1a2e";
    node [fontname="Consolas", fontsize=12];
    edge [fontname="Consolas", fontsize=10];
    
    // Title
    labelloc="t";
    label="PDA for RNA Dot-Bracket Grammar\nGenerated by CFG::toPDA()";
    fontsize=14;
    fontcolor="#ccff00";
    
    // Hidden start
    _start [shape=none, label="", width=0, height=0];
    
    // States
    q0 [shape=circle, label="q0\nstart", style=filled, fillcolor="#00ffff", fontcolor="black"];
    q1 [shape=circle, label="q1\nloop", color="#ffffff", fontcolor="#ffffff"];
    q2 [shape=doublecircle, label="q2\naccept", style=filled, fillcolor="#ccff00", fontcolor="black"];
    
    // Start arrow
    _start -> q0 [color="#00ffff"];
    
    // Transitions
    q0 -> q1 [label="ε, Z → SZ", color="#00ffff"];
    
    q1 -> q1 [label="ε, S → )S(\nε, S → SS\nε, S → .\nε, S → ε\n(, ( → ε\n), ) → ε\n., . → ε", color="#ccff00"];
    
    q1 -> q2 [label="ε, Z → ε", color="#ccff00"];
}
*/

// ============================================================
// C++ ALGORITHM CODE (from pda.cpp)
// ============================================================

/*
PDA CFG::toPDA() const {
    // Standard CFG to PDA construction
    PDA pda;
    StateId q0 = pda.addState("start", false);   // Line 345
    StateId q1 = pda.addState("loop", false);    // Line 346
    StateId q2 = pda.addState("accept", true);   // Line 347
    
    pda.setStartState(q0);                       // Line 349
    pda.setInitialStackSymbol('Z');              // Line 350
    
    // Push start symbol                          // Line 352-353
    pda.addTransition(q0, q1, EPSILON, 'Z', 
                      std::string(1, startSymbol_) + "Z");
    
    // For each production A -> w, pop A and push w (reversed)
    for (const auto& prod : productions_) {      // Line 355-359
        std::string reversed(prod.rhs.rbegin(), prod.rhs.rend());
        pda.addTransition(q1, q1, EPSILON, prod.lhs, reversed);
    }
    
    // For each terminal a, pop a on input a     // Line 361-364
    for (char t : terminals_) {
        pda.addTransition(q1, q1, t, t, "");
    }
    
    // Accept when stack has only Z              // Line 366-367
    pda.addTransition(q1, q2, EPSILON, 'Z', "");
    
    return pda;                                   // Line 369
}
*/
